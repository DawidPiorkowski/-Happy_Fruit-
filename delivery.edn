(ns happy-fruit.core)

;; Define List of Cities with their Corresponding Dara
(def cities
" A vector of maps which contain the cities and their stock and capacity properites "
  [{:name "Munich" :initial 500 :min-capacity 100 :max-capacity 500 :current-stock 500}
   {:name "Napoli" :initial 20 :min-capacity 70 :max-capacity 100 :current-stock 20}
   {:name "Innsbruck" :initial 50 :min-capacity 60 :max-capacity 150 :current-stock 50}
   {:name "Krakov" :initial 0 :min-capacity 80 :max-capacity 100 :current-stock 0}
   {:name "Hamburg" :initial 10 :min-capacity 20 :max-capacity 50 :current-stock 10}])

;; Define Truck Properties
(def truck-capacity 
    "The capacity of each truck in cans."
  100)
(def truck-count
    "The number of available trucks."
  2)

;; Function to identify cities that need supply
(defn cities-needing-supply
    "Returns a list of cities that have current stock below their minimum capacity."
  [cities]
  (filter #(> (:min-capacity %) (:current-stock %)) cities))

;; Function to find cities that have extra supply
(defn cities-with-excess
    "Returns a list of cities that have current stock above their minimum capacity."
  [cities]
  (filter #(> (:current-stock %) (:min-capacity %)) cities))

;; Function to transport cans from source to destination with driver confirmation
(defn transport-cans
    "Transports a specified amount of cans from a source city to a destination city, limited by the destination's capacity.
  - `source`: Source city map
  - `dest`: Destination city map
  - `amount`: Amount of cans to transport
  - `truck-id`: The ID of the truck used for the transport
  Returns updated source and destination city maps."

  [source dest amount truck-id]
  (let [actual-amount (min amount (- (:max-capacity dest) (:current-stock dest)))]
    ;; Driver confirmation message with which truck it is 
    (println "Truck" truck-id "confirmation: Delivering" actual-amount "cans from" (:name source) "to" (:name dest))
    [(assoc source :current-stock (- (:current-stock source) actual-amount))
     (assoc dest :current-stock (+ (:current-stock dest) actual-amount))]))

;; Simulate one truck trip to rebalance stocks with changing trucks 
(defn move-truck [cities truck-id]
  (let [needs-supply (cities-needing-supply cities)
        has-excess (cities-with-excess cities)]
    (if (and (seq needs-supply) (seq has-excess))
      (let [source (first has-excess)
            dest (first needs-supply)
            [updated-source updated-dest] (transport-cans source dest truck-capacity truck-id)]
        (map #(cond
                (= (:name %) (:name source)) updated-source
                (= (:name %) (:name dest)) updated-dest
                :else %) cities))
      cities)))

;; Function to run the simulation for a number of truck trips and print stock levels after each trip
(defn truck-trips  [cities trips]
  (loop [current-cities cities
         remaining-trips trips
         trip-number 1
         truck-id 1]
    (if (zero? remaining-trips)
      current-cities
      (let [updated-cities (move-truck current-cities truck-id)
            next-truck-id (if (= truck-id 1) 2 1)] ;; Alternate truck ID between 1 and 2
        ;; Print stock levels after each trip
        (println "\nStock levels after trip" trip-number ":")
        (doseq [city updated-cities]
          (println (:name city) "- Stock:" (:current-stock city)))
        (recur updated-cities (dec remaining-trips) (inc trip-number) next-truck-id)))))

;; Running the simulation
(defn -main []
  (let [trips 4
        final-cities (truck-trips cities trips)]
    (println "\nFinal city stocks after" trips "truck trips:")
    (doseq [city final-cities]
      (println (:name city) "- Stock:" (:current-stock city)))))

;; Ensure the main function is called when running in an online compiler
(-main)
